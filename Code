/**
 * 現金経費精算アプリ - サーバーサイドスクリプト
 * v11.1: 一括申請・画像取得・グルーピング対応版
 */

// 定数定義：シート名
const SHEETS = {
  RECEIPTS: '領収書',
  DETAILS: '明細',
  ACCOUNTS: '勘定科目マスタ',
  USERS: '使用者マスタ',
  LEARNING: '学習データ',
  RULES: '承認ルール設定',
  CSV_CONFIG: 'CSV出力設定'
};

// ステータス定数
const STATUS = {
  DRAFT: '未申請',
  PENDING: '承認待ち',
  APPROVED: '承認済',
  REJECTED: '差戻し'
};

// APIキー設定
const GEMINI_API_KEY = PropertiesService.getScriptProperties().getProperty('GEMINI_API_KEY') || '';
// 領収書保存先フォルダID
const RECEIPT_FOLDER_ID = PropertiesService.getScriptProperties().getProperty('RECEIPT_FOLDER_ID') || '';

function doGet(e) {
  return HtmlService.createTemplateFromFile('index')
    .evaluate()
    .setTitle('現金経費精算アプリ')
    .addMetaTag('viewport', 'width=device-width, initial-scale=1');
}

/**
 * 初期セットアップ
 */
function setupSpreadsheet() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const headers = {
    [SHEETS.RECEIPTS]: ['登録ID', '登録日時', '申請区分', '利用日', '使用者', '支払先', '合計金額', 'メモ', 'ファイル名', 'ファイルID', 'インボイス有無', 'ステータス', '現在の承認者'],
    [SHEETS.DETAILS]: ['明細ID', '親登録ID', '勘定科目', '項目名', '日当・宿泊', '取引先', '参加人数', '金額(税込)', '税抜', '消費税', 'メモ'],
    [SHEETS.ACCOUNTS]: ['科目名', 'メモ'],
    [SHEETS.USERS]: ['氏名', 'メールアドレス', '権限', '銀行コード', '修正可否'],
    [SHEETS.LEARNING]: ['品目キーワード', '正解勘定科目', '登録回数'],
    [SHEETS.RULES]: ['ルールID', '優先順位', '対象科目', '金額条件', 'キーワード条件', '日当条件', '必須承認者ルート'],
    [SHEETS.CSV_CONFIG]: ['出力種別', '列順', 'ヘッダー名', '参照元', 'カラム名', 'フォーマット指定', '文字コード']
  };

  for (const [sheetName, headerRow] of Object.entries(headers)) {
    let sheet = ss.getSheetByName(sheetName);
    if (!sheet) {
      sheet = ss.insertSheet(sheetName);
      sheet.appendRow(headerRow);
      sheet.setFrozenRows(1);
      sheet.getRange(1, 1, 1, headerRow.length).setFontWeight('bold');
    }
  }
}

// --- ヘッダー配列から列マップを生成 ---
function createColumnMap(headerRow) {
  const map = {};
  if (!headerRow) return map;
  headerRow.forEach((h, i) => map[String(h).trim()] = i);
  return map;
}

// --- ユーザー認証 ---
function getCurrentUser(manualEmail = null) {
  const email = manualEmail || Session.getActiveUser().getEmail();
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(SHEETS.USERS);
  const data = sheet.getDataRange().getValues();
  
  const colMap = createColumnMap(data[0]);
  const idxName = colMap['氏名'];
  const idxEmail = colMap['メールアドレス'];
  const idxRole = colMap['権限'];
  const idxCanFix = colMap['修正可否'];

  for (let i = 1; i < data.length; i++) {
    if (idxEmail !== undefined && String(data[i][idxEmail]).trim().toLowerCase() === String(email).trim().toLowerCase()) {
      
      let canFix = false;
      if (idxCanFix !== undefined) {
        const val = String(data[i][idxCanFix]).trim();
        if (val === '可' || val.toUpperCase() === 'TRUE') {
          canFix = true;
        }
      }

      return {
        name: idxName !== undefined ? data[i][idxName] : '',
        email: data[i][idxEmail],
        role: idxRole !== undefined ? data[i][idxRole] : '',
        canFix: canFix
      };
    }
  }
  return { name: '未登録ユーザー', email: email, role: 'UNREGISTERED', canFix: false };
}

function getSpreadsheetUrl() {
  return SpreadsheetApp.getActiveSpreadsheet().getUrl();
}

// --- ダッシュボードデータ取得 ---
function getDashboardData(userEmail) {
  const user = getCurrentUser(userEmail);
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const rSheet = ss.getSheetByName(SHEETS.RECEIPTS);
  
  const result = { user: user, myApplications: [], approvalTasks: [], allApplications: [] };

  if (user.role === 'UNREGISTERED') return result;
  if (rSheet.getLastRow() <= 1) return result;

  const data = rSheet.getDataRange().getValues();
  const colMap = createColumnMap(data[0]);
  const rows = data.slice(1);
  
  const currentUserName = String(user.name).trim();

  const idxId = colMap['登録ID'];
  const idxDate = colMap['登録日時'];
  const idxAppType = colMap['申請区分']; 
  const idxUseDate = colMap['利用日'];
  const idxUser = colMap['使用者'];
  const idxStore = colMap['支払先'];
  const idxAmount = colMap['合計金額'];
  const idxStatus = colMap['ステータス'];
  const idxApprover = colMap['現在の承認者'];

  if (idxStatus === undefined || idxApprover === undefined) return result;

  const myApplications = [];
  const approvalTasks = [];
  const allApplications = [];

  rows.forEach((row) => {
    const formatDateStr = (d) => d instanceof Date ? Utilities.formatDate(d, Session.getScriptTimeZone(), 'yyyy/MM/dd') : String(d);
    
    const status = row[idxStatus];
    const approver = String(row[idxApprover]).trim();

    // 修正・申請可能か判定
    const isStatusEditable = (status === STATUS.DRAFT) || (status === STATUS.REJECTED);
    const canEdit = (isStatusEditable);
    const canSubmit = (status === STATUS.DRAFT);

    const item = {
      id: row[idxId], 
      date: formatDateStr(row[idxDate]), // 登録日（グルーピングに使用）
      appType: idxAppType !== undefined ? row[idxAppType] : '', 
      useDate: formatDateStr(row[idxUseDate]),
      user: row[idxUser], 
      store: row[idxStore], 
      amount: row[idxAmount], 
      category: '詳細', 
      status: status, 
      approver: approver,
      canEdit: canEdit,
      canSubmit: canSubmit
    };

    // 1. マイ申請履歴
    if (String(item.user).trim() === currentUserName) {
        myApplications.push(item);
    }
    
    // 2. 承認タスク
    if (String(item.approver).trim() === String(user.role).trim() && item.status === STATUS.PENDING) {
        approvalTasks.push(item);
    }

    // 3. 全申請履歴 (経理のみ)
    if (user.role === '経理') {
        allApplications.push(item);
    }
  });

  result.myApplications = myApplications.reverse();
  result.approvalTasks = approvalTasks.reverse(); // 新しい順
  if (user.role === '経理') {
      result.allApplications = allApplications.reverse();
  }

  return result;
}

// --- 申請詳細取得 (修正用 + 画像取得) ---
function getApplicationDetail(id) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const rSheet = ss.getSheetByName(SHEETS.RECEIPTS);
  const dSheet = ss.getSheetByName(SHEETS.DETAILS);
  
  const rData = rSheet.getDataRange().getValues();
  const rColMap = createColumnMap(rData[0]);
  const idxId = rColMap['登録ID'];
  const idxFileId = rColMap['ファイルID'];

  let receipt = null;
  let fileId = null;

  for (let i = 1; i < rData.length; i++) {
    if (rData[i][idxId] == id) {
      const formatDate = (d) => {
        if (!d) return '';
        if (d instanceof Date) return Utilities.formatDate(d, Session.getScriptTimeZone(), 'yyyy-MM-dd');
        return String(d).substr(0, 10);
      };

      fileId = rData[i][idxFileId];

      receipt = {
        id: rData[i][idxId],
        appType: rData[i][rColMap['申請区分']],
        useDate: formatDate(rData[i][rColMap['利用日']]),
        storeName: rData[i][rColMap['支払先']],
        totalAmount: rData[i][rColMap['合計金額']],
        memo: rData[i][rColMap['メモ']],
        hasInvoice: rData[i][rColMap['インボイス有無']],
        fileName: rData[i][rColMap['ファイル名']],
        items: [],
        fileBase64: null,
        mimeType: null
      };
      break;
    }
  }

  if (!receipt) throw new Error('データが見つかりません');

  // 画像データの取得
  if (fileId && fileId !== 'NO_FILE' && fileId !== 'SAVE_ERROR') {
    try {
      const file = DriveApp.getFileById(fileId);
      const blob = file.getBlob();
      receipt.fileBase64 = Utilities.base64Encode(blob.getBytes());
      receipt.mimeType = blob.getContentType();
    } catch (e) {
      console.error('画像取得エラー:', e);
      // エラーでも処理は続行（画像なしとして扱う）
    }
  }

  // 明細データの取得
  const dData = dSheet.getDataRange().getValues();
  const dColMap = createColumnMap(dData[0]);
  const idxDParent = dColMap['親登録ID'];
  
  const detailRows = dData.slice(1).filter(row => row[idxDParent] == id);
  
  receipt.items = detailRows.map(row => ({
    category: row[dColMap['勘定科目']] || '',
    itemName: row[dColMap['項目名']] || '',
    isAllowance: row[dColMap['日当・宿泊']] || false,
    client: row[dColMap['取引先']] || '',
    participants: row[dColMap['参加人数']] || '',
    total_price: row[dColMap['金額(税込)']] || 0
  }));

  if (receipt.items.length === 0) {
    receipt.items.push({
      category: '', itemName: '', total_price: receipt.totalAmount, 
      isAllowance: false, client: '', participants: ''
    });
  }

  return receipt;
}

// --- 登録処理 (保存のみ・未申請状態) ---
function saveApplication(formData, itemsData) {
  const lock = LockService.getScriptLock();
  try {
    lock.waitLock(30000); 

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const rSheet = ss.getSheetByName(SHEETS.RECEIPTS);
    const dSheet = ss.getSheetByName(SHEETS.DETAILS);
    const regId = Utilities.getUuid();
    const now = new Date();
    
    let fileId = 'NO_FILE';
    if (formData.fileBase64) {
      try {
        const folder = RECEIPT_FOLDER_ID ? DriveApp.getFolderById(RECEIPT_FOLDER_ID) : DriveApp.getRootFolder();
        const blob = Utilities.newBlob(Utilities.base64Decode(formData.fileBase64), formData.mimeType, formData.fileName);
        fileId = folder.createFile(blob).getId();
      } catch (e) { console.error(e); fileId = 'SAVE_ERROR'; }
    }

    let finalItems = itemsData && itemsData.length > 0 ? itemsData : [{
      itemName: formData.itemName || '明細なし',
      total_price: formData.totalAmount,
      category: formData.category,
      isAllowance: formData.isAllowance,
      client: formData.client,
      participants: formData.participants
    }];

    const initialStatus = STATUS.DRAFT;
    const firstApprover = '-';

    // 1. 領収書シート(Header)
    const rHeaders = rSheet.getRange(1, 1, 1, rSheet.getLastColumn()).getValues()[0];
    const rRowData = rHeaders.map(header => {
      const h = String(header).trim();
      switch(h) {
        case '登録ID': return regId;
        case '登録日時': return now;
        case '申請区分': return formData.appType;
        case '利用日': return formData.useDate;
        case '使用者': return formData.userName;
        case '支払先': return formData.storeName;
        case '合計金額': return formData.totalAmount;
        case 'メモ': return formData.memo;
        case 'ファイル名': return formData.fileName || '領収書なし';
        case 'ファイルID': return fileId;
        case 'インボイス有無': return formData.hasInvoice;
        case 'ステータス': return initialStatus;
        case '現在の承認者': return firstApprover;
        default: return '';
      }
    });
    rSheet.appendRow(rRowData);

    // 2. 明細シート(Detail)
    const dHeaders = dSheet.getRange(1, 1, 1, dSheet.getLastColumn()).getValues()[0];
    finalItems.forEach(item => {
      if (item.category) updateLearningData(item.itemName, item.category);
      
      const price = Number(item.total_price);
      const subtotal = Math.round(price / 1.1);
      const tax = price - subtotal;

      const dRowData = dHeaders.map(header => {
        const h = String(header).trim();
        switch(h) {
          case '明細ID': return Utilities.getUuid();
          case '親登録ID': return regId;
          case '勘定科目': return item.category || '';
          case '項目名': return item.itemName || '項目不明';
          case '日当・宿泊': return item.isAllowance || false;
          case '取引先': return item.client || '';
          case '参加人数': return item.participants || '';
          case '金額(税込)': return price;
          case '税抜': return subtotal;
          case '消費税': return tax;
          case 'メモ': return ''; 
          default: return '';
        }
      });
      dSheet.appendRow(dRowData);
    });
    
    SpreadsheetApp.flush();
    return { success: true, message: '登録完了（ダッシュボードから申請してください）', id: regId };

  } catch (e) {
    throw new Error('保存エラー: ' + e.message);
  } finally {
    lock.releaseLock();
  }
}

// 修正保存
function updateApplication(formData) {
  const lock = LockService.getScriptLock();
  try {
    lock.waitLock(30000); 

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const rSheet = ss.getSheetByName(SHEETS.RECEIPTS);
    const dSheet = ss.getSheetByName(SHEETS.DETAILS);
    const now = new Date();
    const id = formData.id;

    if (!id) throw new Error('更新対象のIDが指定されていません');

    // 画像更新処理
    let fileId = null;
    if (formData.fileBase64) {
      try {
        const folder = RECEIPT_FOLDER_ID ? DriveApp.getFolderById(RECEIPT_FOLDER_ID) : DriveApp.getRootFolder();
        const blob = Utilities.newBlob(Utilities.base64Decode(formData.fileBase64), formData.mimeType, formData.fileName);
        fileId = folder.createFile(blob).getId();
      } catch (e) { console.error(e); }
    }

    const items = formData.items || [];

    const rData = rSheet.getDataRange().getValues();
    const rColMap = createColumnMap(rData[0]);
    const idxId = rColMap['登録ID'];
    let rowIndex = -1;

    for (let i = 1; i < rData.length; i++) {
      if (rData[i][idxId] == id) {
        rowIndex = i + 1;
        break;
      }
    }

    if (rowIndex === -1) throw new Error('更新対象のデータが見つかりません');

    const setVal = (colName, val) => {
      const col = rColMap[colName];
      if (col !== undefined) rSheet.getRange(rowIndex, col + 1).setValue(val);
    };

    setVal('登録日時', now); 
    setVal('申請区分', formData.appType);
    setVal('利用日', formData.useDate);
    setVal('支払先', formData.storeName);
    setVal('合計金額', formData.totalAmount);
    setVal('メモ', formData.memo);
    setVal('インボイス有無', formData.hasInvoice);
    setVal('ステータス', STATUS.DRAFT);
    setVal('現在の承認者', '-');

    if (fileId) {
       setVal('ファイル名', formData.fileName);
       setVal('ファイルID', fileId);
    }

    // 2. 明細シート(Detail)更新
    const dData = dSheet.getDataRange().getValues();
    const dColMap = createColumnMap(dData[0]);
    const idxDParent = dColMap['親登録ID'];
    
    for (let i = dData.length - 1; i >= 1; i--) {
      if (dData[i][idxDParent] == id) {
        dSheet.deleteRow(i + 1);
      }
    }

    const dHeaders = dSheet.getRange(1, 1, 1, dSheet.getLastColumn()).getValues()[0];
    
    items.forEach(item => {
      if (item.category) updateLearningData(item.itemName, item.category);
      const price = Number(item.total_price);
      const subtotal = Math.round(price / 1.1);
      const tax = price - subtotal;

      const dRowData = dHeaders.map(header => {
        const h = String(header).trim();
        switch(h) {
          case '明細ID': return Utilities.getUuid();
          case '親登録ID': return id;
          case '勘定科目': return item.category || '';
          case '項目名': return item.itemName || '項目不明';
          case '日当・宿泊': return item.isAllowance || false;
          case '取引先': return item.client || '';
          case '参加人数': return item.participants || '';
          case '金額(税込)': return price;
          case '税抜': return subtotal;
          case '消費税': return tax;
          case 'メモ': return ''; 
          default: return '';
        }
      });
      dSheet.appendRow(dRowData);
    });
    
    SpreadsheetApp.flush();
    return { success: true, message: '修正・登録完了（ダッシュボードから申請してください）', id: id };

  } catch (e) {
    throw new Error('更新エラー: ' + e.message);
  } finally {
    lock.releaseLock();
  }
}

// --- ダッシュボードからの申請処理 (一括申請対応) ---
function submitBulkApplications(ids) {
  const lock = LockService.getScriptLock();
  try {
    lock.waitLock(30000);
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const rSheet = ss.getSheetByName(SHEETS.RECEIPTS);
    const rData = rSheet.getDataRange().getValues();
    const rColMap = createColumnMap(rData[0]);
    
    const idxId = rColMap['登録ID'];
    const idxStatus = rColMap['ステータス'];
    const idxApprover = rColMap['現在の承認者'];
    const idxAmount = rColMap['合計金額'];

    const dSheet = ss.getSheetByName(SHEETS.DETAILS);
    const dData = dSheet.getDataRange().getValues();
    const dColMap = createColumnMap(dData[0]);
    const idxDParent = dColMap['親登録ID'];
    const idxDCat = dColMap['勘定科目'];
    const idxDItem = dColMap['項目名'];
    const idxDAllow = dColMap['日当・宿泊'];
    const idxDPrice = dColMap['金額(税込)'];

    // IDごとの明細をグループ化
    const detailsMap = {};
    dData.slice(1).forEach(row => {
        const pId = row[idxDParent];
        if (!detailsMap[pId]) detailsMap[pId] = [];
        detailsMap[pId].push({
            category: row[idxDCat],
            name: row[idxDItem],
            isAllowance: row[idxDAllow],
            total_price: row[idxDPrice]
        });
    });

    let successCount = 0;

    for (let i = 1; i < rData.length; i++) {
      const id = rData[i][idxId];
      if (ids.includes(String(id))) {
        const currentStatus = rData[i][idxStatus];
        if (currentStatus === STATUS.DRAFT || currentStatus === STATUS.REJECTED) {
            
            const amount = rData[i][idxAmount];
            const items = detailsMap[id] || [];
            
            // ルート判定
            const mainItem = items.reduce((prev, current) => (Number(prev.total_price) > Number(current.total_price)) ? prev : current, items[0] || {category:''});
            const hasAllowance = items.some(it => it.isAllowance);
            
            const route = getApprovalRoute(mainItem.category, amount, items, hasAllowance);
            const firstApprover = route.length > 0 ? route[0] : STATUS.APPROVED;
            const nextStatus = firstApprover === STATUS.APPROVED ? STATUS.APPROVED : STATUS.PENDING;

            rSheet.getRange(i + 1, idxStatus + 1).setValue(nextStatus);
            rSheet.getRange(i + 1, idxApprover + 1).setValue(firstApprover);
            successCount++;
        }
      }
    }

    SpreadsheetApp.flush();
    return { success: true, message: `${successCount}件の申請を提出しました` };

  } catch (e) {
    throw new Error('申請エラー: ' + e.message);
  } finally {
    lock.releaseLock();
  }
}

// 単一申請用（一括申請関数を利用）
function submitApplicationFromDashboard(id) {
    return submitBulkApplications([id]);
}


// --- 申請削除処理 ---
function deleteApplication(id) {
  const lock = LockService.getScriptLock();
  try {
    lock.waitLock(30000);
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    
    // 1. 領収書データの削除
    const rSheet = ss.getSheetByName(SHEETS.RECEIPTS);
    const rData = rSheet.getDataRange().getValues();
    const rColMap = createColumnMap(rData[0]);
    const idxRId = rColMap['登録ID'];
    
    let deleted = false;
    for (let i = rData.length - 1; i >= 1; i--) {
      if (rData[i][idxRId] == id) {
        rSheet.deleteRow(i + 1);
        deleted = true;
        break; 
      }
    }
    
    if (!deleted) throw new Error('削除対象の申請が見つかりません');

    // 2. 明細データの削除
    const dSheet = ss.getSheetByName(SHEETS.DETAILS);
    const dData = dSheet.getDataRange().getValues();
    const dColMap = createColumnMap(dData[0]);
    const idxDParent = dColMap['親登録ID'];

    for (let i = dData.length - 1; i >= 1; i--) {
      if (dData[i][idxDParent] == id) {
        dSheet.deleteRow(i + 1);
      }
    }
    
    return { success: true, message: '削除しました' };

  } catch(e) {
    throw new Error('削除エラー: ' + e.message);
  } finally {
    lock.releaseLock();
  }
}

// --- 承認処理 ---
function approveApplication(id, userEmail) {
  const lock = LockService.getScriptLock();
  try {
    lock.waitLock(30000);

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const rSheet = ss.getSheetByName(SHEETS.RECEIPTS);
    const data = rSheet.getDataRange().getValues();
    const colMap = createColumnMap(data[0]);

    const idxId = colMap['登録ID'];
    const idxApprover = colMap['現在の承認者'];
    const idxStatus = colMap['ステータス'];
    const idxAmount = colMap['合計金額'];
    
    const dSheet = ss.getSheetByName(SHEETS.DETAILS);
    const dData = dSheet.getDataRange().getValues();
    const dColMap = createColumnMap(dData[0]);
    const idxDId = dColMap['親登録ID'];
    const idxDCat = dColMap['勘定科目'];
    const idxDItem = dColMap['項目名'];
    const idxDAllow = dColMap['日当・宿泊'];
    const idxDPrice = dColMap['金額(税込)'];

    for (let i = 1; i < data.length; i++) {
      if (data[i][idxId] == id) {
        const currentRole = data[i][idxApprover];
        
        const items = dData.slice(1).filter(d => d[idxDId] == id).map(r => ({
           category: r[idxDCat],
           name: r[idxDItem],
           isAllowance: r[idxDAllow],
           total_price: r[idxDPrice]
        }));
        
        const mainItem = items.reduce((prev, current) => (Number(prev.total_price) > Number(current.total_price)) ? prev : current, items[0] || {category:''});
        const isAllowance = items.some(r => r.isAllowance);
        const amount = data[i][idxAmount];

        const route = getApprovalRoute(mainItem.category, amount, items, isAllowance);
        const idx = route.indexOf(currentRole);
        
        if (idx !== -1 && idx < route.length - 1) {
          rSheet.getRange(i + 1, idxApprover + 1).setValue(route[idx + 1]);
        } else {
          rSheet.getRange(i + 1, idxStatus + 1).setValue(STATUS.APPROVED);
          rSheet.getRange(i + 1, idxApprover + 1).setValue(STATUS.APPROVED);
        }
        SpreadsheetApp.flush();
        return { success: true };
      }
    }
    return { success: false, message: 'データが見つかりません' };

  } catch (e) {
    throw new Error('承認エラー: ' + e.message);
  } finally {
    lock.releaseLock();
  }
}

// --- 差戻し処理 ---
function rejectApplication(id, comment) {
  const lock = LockService.getScriptLock();
  try {
    lock.waitLock(30000);
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(SHEETS.RECEIPTS);
    const data = sheet.getDataRange().getValues();
    const colMap = createColumnMap(data[0]);
    
    const idxId = colMap['登録ID'];
    const idxStatus = colMap['ステータス'];
    const idxMemo = colMap['メモ'];

    for (let i = 1; i < data.length; i++) {
      if (data[i][idxId] == id) {
        if(idxStatus !== undefined) sheet.getRange(i + 1, idxStatus + 1).setValue(STATUS.REJECTED);
        if(idxMemo !== undefined) {
           const currentMemo = data[i][idxMemo];
           sheet.getRange(i + 1, idxMemo + 1).setValue(currentMemo + `\n[差戻し理由] ${comment}`);
        }
        SpreadsheetApp.flush();
        return { success: true };
      }
    }
  } catch(e) {
    throw new Error('エラー: ' + e.message);
  } finally {
    lock.releaseLock();
  }
}

// --- AI解析 ---
function analyzeReceiptImage(base64Image, mimeType) {
  if (!GEMINI_API_KEY) throw new Error('Gemini APIキーが設定されていません。');
  const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro:generateContent?key=${GEMINI_API_KEY}`;
  
  const prompt = `
    你是経理入力支援AIです。領収書画像を読み取り、以下のJSON形式で出力してください。
    
    【抽出ルール】
    1. use_date: 利用日(YYYY-MM-DD)。不明なら今日。
    2. store_name: 支払先・店名。
    3. total_amount: 税込合計金額(数値)。
    4. item_name: 最も代表的な但し書き・品目名(例: タクシー代、飲食代)。
    5. category: 品目から推測される勘定科目(旅費交通費/交際費/消耗品/会議費/研修費/その他)。不明なら空文字。
    6. client: 接待相手の社名や氏名(記載があれば)。なければ空文字。
    7. participants: 参加人数(記載があれば数値)。なければ空文字。
    8. has_invoice: Tから始まる13桁の登録番号があればtrue。
    9. summary_text: 【重要】領収書の読み取り内容（日付、店名、金額、登録番号、品目など）を要約したテキストを作成してください。

    出力例:
    {
      "use_date": "2024-04-01",
      "store_name": "セブンイレブン",
      "total_amount": 550,
      "item_name": "文房具代",
      "category": "消耗品",
      "client": "",
      "participants": "",
      "has_invoice": true,
      "summary_text": "[AI読取]\\n日付: 2024/04/01\\n店名: セブンイレブン..."
    }
    
    JSONのみを返してください。
  `;

  const payload = { contents: [{ parts: [{ text: prompt }, { inline_data: { mime_type: mimeType, data: base64Image } }] }] };
  const options = { method: 'post', contentType: 'application/json', payload: JSON.stringify(payload), muteHttpExceptions: true };

  try {
    const response = UrlFetchApp.fetch(url, options);
    const json = JSON.parse(response.getContentText());
    if (json.error) throw new Error(json.error.message);
    let text = json.candidates[0].content.parts[0].text;
    text = text.replace(/```json/g, '').replace(/```/g, '').trim();
    return JSON.parse(text);
  } catch (e) {
    console.error('AI Error:', e);
    throw new Error('AI解析失敗: ' + e.message);
  }
}

// --- 学習データ関連 ---
function updateLearningData(itemName, category) {
  if (!itemName || !category) return;
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(SHEETS.LEARNING);
  sheet.appendRow([itemName, category, 1]);
}

function predictCategoryByItem(itemName) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(SHEETS.LEARNING);
  const data = sheet.getDataRange().getValues();
  const counts = {};
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] === itemName) {
      const cat = data[i][1];
      counts[cat] = (counts[cat] || 0) + Number(data[i][2] || 1);
    }
  }
  let max = 0;
  let bestCategory = '';
  for (const [cat, count] of Object.entries(counts)) {
    if (count > max) { max = count; bestCategory = cat; }
  }
  return bestCategory; 
}

function suggestItemsByCategory(category) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(SHEETS.LEARNING);
  const data = sheet.getDataRange().getValues();
  const suggestions = {};
  for (let i = 1; i < data.length; i++) {
    if (data[i][1] === category) {
      const name = data[i][0];
      suggestions[name] = (suggestions[name] || 0) + Number(data[i][2] || 1);
    }
  }
  return Object.entries(suggestions)
    .sort((a, b) => b[1] - a[1])
    .map(s => s[0])
    .slice(0, 10);
}

function getMasters() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const accounts = ss.getSheetByName(SHEETS.ACCOUNTS).getDataRange().getValues().slice(1).map(r => r[0]);
  return { accounts: accounts };
}

function getApprovalRoute(category, amount, items, hasAllowance) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(SHEETS.RULES);
  const data = sheet.getDataRange().getValues();
  
  const colMap = createColumnMap(data[0]);
  const idxCat = colMap['対象科目'];
  const idxAmt = colMap['金額条件'];
  const idxKw = colMap['キーワード条件'];
  const idxAllow = colMap['日当条件'];
  const idxRoute = colMap['必須承認者ルート'];

  const rules = data.slice(1).sort((a, b) => a[1] - b[1]);

  for (const rule of rules) {
    let match = true;
    
    if (idxCat !== undefined && rule[idxCat] && rule[idxCat] !== '*' && rule[idxCat] !== category) match = false;
    if (idxAmt !== undefined && rule[idxAmt] && amount < rule[idxAmt]) match = false;
    if (idxKw !== undefined && rule[idxKw]) {
      const allText = items.map(i => i.name).join(' ');
      if (!allText.includes(rule[idxKw])) match = false;
    }
    if (idxAllow !== undefined) {
      const ruleAllowance = rule[idxAllow];
      if (String(ruleAllowance).toUpperCase() === 'TRUE' && !hasAllowance) match = false;
    }

    if (match) {
      if(idxRoute !== undefined) return rule[idxRoute].split(',').map(s => s.trim()).filter(s => s);
    }
  }
  return [];
}

function generateCSV(type) {
  const lock = LockService.getScriptLock();
  try {
    lock.waitLock(30000);

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const configSheet = ss.getSheetByName(SHEETS.CSV_CONFIG);
    const configData = configSheet.getDataRange().getValues();
    const configColMap = createColumnMap(configData[0]);
    const idxType = configColMap['出力種別'];
    const idxOrder = configColMap['列順'];
    const idxHeader = configColMap['ヘッダー名']; 
    const idxCharset = configColMap['文字コード']; 
    
    if (idxType === undefined || idxOrder === undefined) throw new Error('CSV設定シートの形式が不正です');

    const configs = configData.slice(1)
      .filter(r => r[idxType] === type)
      .sort((a, b) => a[idxOrder] - b[idxOrder]);

    if (!configs.length) throw new Error('CSV設定が見つかりません: ' + type);

    let charset = 'Shift_JIS';
    if (idxCharset !== undefined) {
        const settingCharset = String(configs[0][idxCharset]).trim();
        if (settingCharset.toUpperCase() === 'UTF-8') charset = 'UTF-8';
    }

    const rSheet = ss.getSheetByName(SHEETS.RECEIPTS);
    const rData = rSheet.getDataRange().getValues();
    const rColMap = createColumnMap(rData[0]);
    const rMap = new Map();
    const idxRId = rColMap['登録ID'];
    const idxStatus = rColMap['ステータス'];

    rData.slice(1).forEach(row => {
      const id = String(row[idxRId]).trim();
      if (String(row[idxStatus]).trim() === STATUS.APPROVED) {
        rMap.set(id, row);
      }
    });

    const dSheet = ss.getSheetByName(SHEETS.DETAILS);
    const dData = dSheet.getDataRange().getValues();
    const dColMap = createColumnMap(dData[0]);
    const idxDParent = dColMap['親登録ID'];
    
    let csvHeaderRow = configs.map(c => c[idxHeader] || c[2]);
    let csv = csvHeaderRow.join(',') + '\r\n';

    dData.slice(1).forEach(dRow => {
      const parentId = String(dRow[idxDParent]).trim();
      const rRow = rMap.get(parentId);
      if (!rRow) return;

      const line = configs.map(config => {
        const source = config[configColMap['参照元']];
        const colName = String(config[configColMap['カラム名']]).trim();
        const format = config[configColMap['フォーマット指定']];
        
        let value = '';
        if (source === '固定値') {
          value = colName;
        } else {
          let targetRow = (source === '領収書') ? rRow : dRow;
          let targetColMap = (source === '領収書') ? rColMap : dColMap;
          
          let idx = targetColMap ? targetColMap[colName] : undefined;
          if (idx !== undefined) value = targetRow[idx];
        }

        if (format === 'YYYYMMDD' && value instanceof Date) {
          value = Utilities.formatDate(value, Session.getScriptTimeZone(), 'yyyyMMdd');
        }
        return `"${String(value).replace(/"/g, '""')}"`;
      }).join(',');

      csv += line + '\r\n';
    });

    const blob = Utilities.newBlob('', 'text/csv', type + '.csv').setDataFromString(csv, charset);
    return {
      base64: Utilities.base64Encode(blob.getBytes()),
      filename: `${type}_${Utilities.formatDate(new Date(), Session.getScriptTimeZone(), 'yyyyMMdd_HHmm')}.csv`
    };
  } catch (e) {
    throw new Error('CSV出力エラー: ' + e.message);
  } finally {
    lock.releaseLock();
  }
}
