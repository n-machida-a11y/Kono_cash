/**
 * AI経費精算システム - サーバーサイドスクリプト
 * v10.0: マルチ明細（1申請複数行）対応版
 */

// 定数定義：シート名
const SHEETS = {
  RECEIPTS: '領収書',
  DETAILS: '明細',
  ACCOUNTS: '勘定科目マスタ',
  USERS: '使用者マスタ',
  LEARNING: '学習データ',
  RULES: '承認ルール設定',
  CSV_CONFIG: 'CSV出力設定'
};

// APIキー設定
const GEMINI_API_KEY = PropertiesService.getScriptProperties().getProperty('GEMINI_API_KEY') || '';
// 領収書保存先フォルダID
const RECEIPT_FOLDER_ID = PropertiesService.getScriptProperties().getProperty('RECEIPT_FOLDER_ID') || '';

function doGet(e) {
  return HtmlService.createTemplateFromFile('index')
    .evaluate()
    .setTitle('AI経費精算システム v10')
    .addMetaTag('viewport', 'width=device-width, initial-scale=1');
}

/**
 * 初期セットアップ
 */
function setupSpreadsheet() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const headers = {
    [SHEETS.RECEIPTS]: ['登録ID', '登録日時', '申請区分', '利用日', '使用者', '支払先', '合計金額', 'メモ', 'ファイル名', 'ファイルID', 'インボイス有無', 'ステータス', '現在の承認者'],
    [SHEETS.DETAILS]: ['明細ID', '親登録ID', '勘定科目', '項目名', '日当・宿泊', '取引先', '参加人数', '金額(税込)', '税抜', '消費税', 'メモ'],
    [SHEETS.ACCOUNTS]: ['科目名', 'メモ'],
    [SHEETS.USERS]: ['氏名', 'メールアドレス', '権限', '銀行コード', '修正可否'],
    [SHEETS.LEARNING]: ['品目キーワード', '正解勘定科目', '登録回数'],
    [SHEETS.RULES]: ['ルールID', '優先順位', '対象科目', '金額条件', 'キーワード条件', '日当条件', '必須承認者ルート'],
    [SHEETS.CSV_CONFIG]: ['出力種別', '列順', 'ヘッダー名', '参照元', 'カラム名', 'フォーマット指定', '文字コード']
  };

  for (const [sheetName, headerRow] of Object.entries(headers)) {
    let sheet = ss.getSheetByName(sheetName);
    if (!sheet) {
      sheet = ss.insertSheet(sheetName);
      sheet.appendRow(headerRow);
      sheet.setFrozenRows(1);
      sheet.getRange(1, 1, 1, headerRow.length).setFontWeight('bold');
    }
  }
}

// --- ヘッダー配列から列マップを生成 ---
function createColumnMap(headerRow) {
  const map = {};
  if (!headerRow) return map;
  headerRow.forEach((h, i) => map[String(h).trim()] = i);
  return map;
}

// --- ユーザー認証 ---
function getCurrentUser(manualEmail = null) {
  const email = manualEmail || Session.getActiveUser().getEmail();
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(SHEETS.USERS);
  const data = sheet.getDataRange().getValues();
  
  const colMap = createColumnMap(data[0]);
  const idxName = colMap['氏名'];
  const idxEmail = colMap['メールアドレス'];
  const idxRole = colMap['権限'];
  const idxCanFix = colMap['修正可否'];

  for (let i = 1; i < data.length; i++) {
    if (idxEmail !== undefined && String(data[i][idxEmail]).trim().toLowerCase() === String(email).trim().toLowerCase()) {
      
      let canFix = false;
      if (idxCanFix !== undefined) {
        const val = String(data[i][idxCanFix]).trim();
        if (val === '可' || val.toUpperCase() === 'TRUE') {
          canFix = true;
        }
      }

      return {
        name: idxName !== undefined ? data[i][idxName] : '',
        email: data[i][idxEmail],
        role: idxRole !== undefined ? data[i][idxRole] : '',
        canFix: canFix
      };
    }
  }
  return { name: '未登録ユーザー', email: email, role: 'UNREGISTERED', canFix: false };
}

function getSpreadsheetUrl() {
  return SpreadsheetApp.getActiveSpreadsheet().getUrl();
}

// --- ダッシュボードデータ取得 ---
function getDashboardData(userEmail) {
  const user = getCurrentUser(userEmail);
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const rSheet = ss.getSheetByName(SHEETS.RECEIPTS);
  
  const result = { user: user, myApplications: [], approvalTasks: [], allApplications: [] };

  if (user.role === 'UNREGISTERED') return result;
  if (rSheet.getLastRow() <= 1) return result;

  const data = rSheet.getDataRange().getValues();
  const colMap = createColumnMap(data[0]);
  const rows = data.slice(1);
  
  const currentUserName = String(user.name).trim();

  const idxId = colMap['登録ID'];
  const idxDate = colMap['登録日時'];
  const idxAppType = colMap['申請区分']; 
  const idxUseDate = colMap['利用日'];
  const idxUser = colMap['使用者'];
  const idxStore = colMap['支払先'];
  const idxAmount = colMap['合計金額'];
  const idxStatus = colMap['ステータス'];
  const idxApprover = colMap['現在の承認者'];

  if (idxStatus === undefined || idxApprover === undefined) return result;

  const myApplications = [];
  const approvalTasks = [];
  const allApplications = [];

  rows.forEach((row) => {
    const formatDateStr = (d) => d instanceof Date ? Utilities.formatDate(d, Session.getScriptTimeZone(), 'yyyy/MM/dd') : String(d);
    
    const status = row[idxStatus];
    const approver = String(row[idxApprover]).trim();

    // 修正可能か判定
    const isStatusEditable = (status === '差戻し') || (status === '承認待ち' && approver === '経理');
    const canEdit = user.canFix && isStatusEditable;

    const item = {
      id: row[idxId], 
      date: formatDateStr(row[idxDate]), 
      appType: idxAppType !== undefined ? row[idxAppType] : '', 
      useDate: formatDateStr(row[idxUseDate]),
      user: row[idxUser], 
      store: row[idxStore], 
      amount: row[idxAmount], 
      category: '詳細', // ダッシュボードでは詳細は省略
      status: status, 
      approver: row[idxApprover],
      canEdit: canEdit
    };

    // 1. マイ申請履歴
    if (String(item.user).trim() === currentUserName) {
        myApplications.push(item);
    }
    
    // 2. 承認タスク (承認待ち かつ 自分の権限)
    if (String(item.approver).trim() === String(user.role).trim() && item.status === '承認待ち') {
        approvalTasks.push(item);
    }

    // 3. 全申請履歴 (経理のみ)
    if (user.role === '経理') {
        allApplications.push(item);
    }
  });

  result.myApplications = myApplications.reverse();
  result.approvalTasks = approvalTasks;
  if (user.role === '経理') {
      result.allApplications = allApplications.reverse();
  }

  return result;
}

// --- 申請詳細取得 (修正用・マルチ明細対応) ---
function getApplicationDetail(id) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const rSheet = ss.getSheetByName(SHEETS.RECEIPTS);
  const dSheet = ss.getSheetByName(SHEETS.DETAILS);
  
  const rData = rSheet.getDataRange().getValues();
  const rColMap = createColumnMap(rData[0]);
  const idxId = rColMap['登録ID'];

  let receipt = null;
  for (let i = 1; i < rData.length; i++) {
    if (rData[i][idxId] == id) {
      const formatDate = (d) => {
        if (!d) return '';
        if (d instanceof Date) return Utilities.formatDate(d, Session.getScriptTimeZone(), 'yyyy-MM-dd');
        return String(d).substr(0, 10);
      };

      receipt = {
        id: rData[i][idxId],
        appType: rData[i][rColMap['申請区分']],
        useDate: formatDate(rData[i][rColMap['利用日']]),
        storeName: rData[i][rColMap['支払先']],
        totalAmount: rData[i][rColMap['合計金額']],
        memo: rData[i][rColMap['メモ']],
        hasInvoice: rData[i][rColMap['インボイス有無']],
        items: [] // 明細配列
      };
      break;
    }
  }

  if (!receipt) throw new Error('データが見つかりません');

  // 明細データの取得 (複数行対応)
  const dData = dSheet.getDataRange().getValues();
  const dColMap = createColumnMap(dData[0]);
  const idxDParent = dColMap['親登録ID'];
  
  const detailRows = dData.slice(1).filter(row => row[idxDParent] == id);
  
  receipt.items = detailRows.map(row => ({
    category: row[dColMap['勘定科目']] || '',
    itemName: row[dColMap['項目名']] || '',
    isAllowance: row[dColMap['日当・宿泊']] || false,
    client: row[dColMap['取引先']] || '',
    participants: row[dColMap['参加人数']] || '',
    total_price: row[dColMap['金額(税込)']] || 0
  }));

  // 明細がない場合のフォールバック（通常ありえないが）
  if (receipt.items.length === 0) {
    receipt.items.push({
      category: '', itemName: '', total_price: receipt.totalAmount, 
      isAllowance: false, client: '', participants: ''
    });
  }

  return receipt;
}

// --- 申請更新処理 (マルチ明細対応) ---
function updateApplication(formData) {
  const lock = LockService.getScriptLock();
  try {
    lock.waitLock(30000); 

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const rSheet = ss.getSheetByName(SHEETS.RECEIPTS);
    const dSheet = ss.getSheetByName(SHEETS.DETAILS);
    const now = new Date();
    const id = formData.id;

    if (!id) throw new Error('更新対象のIDが指定されていません');

    // 画像更新処理
    let fileId = null;
    if (formData.fileBase64) {
      try {
        const folder = RECEIPT_FOLDER_ID ? DriveApp.getFolderById(RECEIPT_FOLDER_ID) : DriveApp.getRootFolder();
        const blob = Utilities.newBlob(Utilities.base64Decode(formData.fileBase64), formData.mimeType, formData.fileName);
        fileId = folder.createFile(blob).getId();
      } catch (e) { console.error(e); }
    }

    // 明細データ（フロントエンドから配列で来る）
    const items = formData.items || [];
    
    // 承認ルート再判定（一番金額が高い明細、または特定の優先度で判定。今回は金額合計と代表科目で簡易判定）
    // ※実運用では「最も厳しいルート」を採用するのが一般的ですが、ここでは「1行目の明細」または「全明細」を考慮
    // 簡略化のため、最も金額の大きい明細の科目でルート判定、またはリストの先頭で判定
    const mainItem = items.reduce((prev, current) => (Number(prev.total_price) > Number(current.total_price)) ? prev : current, items[0]);
    
    const route = getApprovalRoute(mainItem.category || '', formData.totalAmount, items, items.some(i => i.isAllowance));
    const firstApprover = route.length > 0 ? route[0] : '承認済';
    const initialStatus = firstApprover === '承認済' ? '承認済' : '承認待ち';

    // 1. 領収書シート(Header)更新
    const rData = rSheet.getDataRange().getValues();
    const rColMap = createColumnMap(rData[0]);
    const idxId = rColMap['登録ID'];
    let rowIndex = -1;

    for (let i = 1; i < rData.length; i++) {
      if (rData[i][idxId] == id) {
        rowIndex = i + 1;
        break;
      }
    }

    if (rowIndex === -1) throw new Error('更新対象のデータが見つかりません');

    const setVal = (colName, val) => {
      const col = rColMap[colName];
      if (col !== undefined) rSheet.getRange(rowIndex, col + 1).setValue(val);
    };

    setVal('登録日時', now); 
    setVal('申請区分', formData.appType);
    setVal('利用日', formData.useDate);
    setVal('支払先', formData.storeName);
    setVal('合計金額', formData.totalAmount);
    setVal('メモ', formData.memo);
    setVal('インボイス有無', formData.hasInvoice);
    setVal('ステータス', initialStatus); 
    setVal('現在の承認者', firstApprover); 

    if (fileId) {
       setVal('ファイル名', formData.fileName);
       setVal('ファイルID', fileId);
    }

    // 2. 明細シート(Detail)更新：既存を削除して全挿入
    const dData = dSheet.getDataRange().getValues();
    const dColMap = createColumnMap(dData[0]);
    const idxDParent = dColMap['親登録ID'];
    
    // 下から削除しないとインデックスがずれる
    for (let i = dData.length - 1; i >= 1; i--) {
      if (dData[i][idxDParent] == id) {
        dSheet.deleteRow(i + 1);
      }
    }

    // 新しい明細を追加
    const dHeaders = dSheet.getRange(1, 1, 1, dSheet.getLastColumn()).getValues()[0];
    
    items.forEach(item => {
      // 学習データ更新
      if (item.category) updateLearningData(item.itemName, item.category);
      
      const price = Number(item.total_price);
      const subtotal = Math.round(price / 1.1);
      const tax = price - subtotal;

      const dRowData = dHeaders.map(header => {
        const h = String(header).trim();
        switch(h) {
          case '明細ID': return Utilities.getUuid();
          case '親登録ID': return id;
          case '勘定科目': return item.category || '';
          case '項目名': return item.itemName || '項目不明';
          case '日当・宿泊': return item.isAllowance || false;
          case '取引先': return item.client || '';
          case '参加人数': return item.participants || '';
          case '金額(税込)': return price;
          case '税抜': return subtotal;
          case '消費税': return tax;
          case 'メモ': return ''; // 明細ごとのメモが必要ならここに追加
          default: return '';
        }
      });
      dSheet.appendRow(dRowData);
    });
    
    SpreadsheetApp.flush();
    return { success: true, message: '修正完了', id: id };

  } catch (e) {
    throw new Error('更新エラー: ' + e.message);
  } finally {
    lock.releaseLock();
  }
}

// --- 申請新規保存 (マルチ明細対応) ---
function saveApplication(formData, itemsData) {
  const lock = LockService.getScriptLock();
  try {
    lock.waitLock(30000); 

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const rSheet = ss.getSheetByName(SHEETS.RECEIPTS);
    const dSheet = ss.getSheetByName(SHEETS.DETAILS);
    const regId = Utilities.getUuid();
    const now = new Date();
    
    let fileId = 'NO_FILE';
    if (formData.fileBase64) {
      try {
        const folder = RECEIPT_FOLDER_ID ? DriveApp.getFolderById(RECEIPT_FOLDER_ID) : DriveApp.getRootFolder();
        const blob = Utilities.newBlob(Utilities.base64Decode(formData.fileBase64), formData.mimeType, formData.fileName);
        fileId = folder.createFile(blob).getId();
      } catch (e) { console.error(e); fileId = 'SAVE_ERROR'; }
    }

    // itemsDataはフロントエンドから渡された明細配列
    let finalItems = itemsData && itemsData.length > 0 ? itemsData : [{
      itemName: formData.itemName || '明細なし',
      total_price: formData.totalAmount,
      category: formData.category,
      isAllowance: formData.isAllowance,
      client: formData.client,
      participants: formData.participants
    }];

    // ルート判定（代表明細または全明細考慮）
    const mainItem = finalItems.reduce((prev, current) => (Number(prev.total_price) > Number(current.total_price)) ? prev : current, finalItems[0]);
    const route = getApprovalRoute(mainItem.category || '', formData.totalAmount, finalItems, finalItems.some(i => i.isAllowance));
    
    const firstApprover = route.length > 0 ? route[0] : '承認済';
    const initialStatus = firstApprover === '承認済' ? '承認済' : '承認待ち';

    // 1. 領収書シート(Header)
    const rHeaders = rSheet.getRange(1, 1, 1, rSheet.getLastColumn()).getValues()[0];
    const rRowData = rHeaders.map(header => {
      const h = String(header).trim();
      switch(h) {
        case '登録ID': return regId;
        case '登録日時': return now;
        case '申請区分': return formData.appType;
        case '利用日': return formData.useDate;
        case '使用者': return formData.userName;
        case '支払先': return formData.storeName;
        case '合計金額': return formData.totalAmount;
        case 'メモ': return formData.memo;
        case 'ファイル名': return formData.fileName || '領収書なし';
        case 'ファイルID': return fileId;
        case 'インボイス有無': return formData.hasInvoice;
        case 'ステータス': return initialStatus;
        case '現在の承認者': return firstApprover;
        default: return '';
      }
    });
    rSheet.appendRow(rRowData);

    // 2. 明細シート(Detail)
    const dHeaders = dSheet.getRange(1, 1, 1, dSheet.getLastColumn()).getValues()[0];
    finalItems.forEach(item => {
      if (item.category) updateLearningData(item.itemName, item.category);
      
      const price = Number(item.total_price);
      const subtotal = Math.round(price / 1.1);
      const tax = price - subtotal;

      const dRowData = dHeaders.map(header => {
        const h = String(header).trim();
        switch(h) {
          case '明細ID': return Utilities.getUuid();
          case '親登録ID': return regId;
          case '勘定科目': return item.category || '';
          case '項目名': return item.itemName || '項目不明';
          case '日当・宿泊': return item.isAllowance || false;
          case '取引先': return item.client || '';
          case '参加人数': return item.participants || '';
          case '金額(税込)': return price;
          case '税抜': return subtotal;
          case '消費税': return tax;
          case 'メモ': return ''; 
          default: return '';
        }
      });
      dSheet.appendRow(dRowData);
    });
    
    SpreadsheetApp.flush();
    return { success: true, message: '申請完了', id: regId };

  } catch (e) {
    throw new Error('保存エラー: ' + e.message);
  } finally {
    lock.releaseLock();
  }
}

// --- 申請削除処理 ---
function deleteApplication(id) {
  const lock = LockService.getScriptLock();
  try {
    lock.waitLock(30000);
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    
    // 1. 領収書データの削除
    const rSheet = ss.getSheetByName(SHEETS.RECEIPTS);
    const rData = rSheet.getDataRange().getValues();
    const rColMap = createColumnMap(rData[0]);
    const idxRId = rColMap['登録ID'];
    
    let deleted = false;
    for (let i = rData.length - 1; i >= 1; i--) {
      if (rData[i][idxRId] == id) {
        rSheet.deleteRow(i + 1);
        deleted = true;
        break; 
      }
    }
    
    if (!deleted) throw new Error('削除対象の申請が見つかりません');

    // 2. 明細データの削除
    const dSheet = ss.getSheetByName(SHEETS.DETAILS);
    const dData = dSheet.getDataRange().getValues();
    const dColMap = createColumnMap(dData[0]);
    const idxDParent = dColMap['親登録ID'];

    for (let i = dData.length - 1; i >= 1; i--) {
      if (dData[i][idxDParent] == id) {
        dSheet.deleteRow(i + 1);
      }
    }
    
    return { success: true, message: '削除しました' };

  } catch(e) {
    throw new Error('削除エラー: ' + e.message);
  } finally {
    lock.releaseLock();
  }
}

// --- 承認処理 (変更なし) ---
function approveApplication(id, userEmail) {
  const lock = LockService.getScriptLock();
  try {
    lock.waitLock(30000);

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const rSheet = ss.getSheetByName(SHEETS.RECEIPTS);
    const data = rSheet.getDataRange().getValues();
    const colMap = createColumnMap(data[0]);

    const idxId = colMap['登録ID'];
    const idxApprover = colMap['現在の承認者'];
    const idxStatus = colMap['ステータス'];
    const idxAmount = colMap['合計金額'];
    
    if (idxId === undefined || idxApprover === undefined || idxStatus === undefined) {
      throw new Error('必要な列が見つかりません');
    }

    const dSheet = ss.getSheetByName(SHEETS.DETAILS);
    const dData = dSheet.getDataRange().getValues();
    const dColMap = createColumnMap(dData[0]);
    
    const idxDId = dColMap['親登録ID'];
    const idxDCat = dColMap['勘定科目'];
    const idxDItem = dColMap['項目名'];
    const idxDAllow = dColMap['日当・宿泊'];

    for (let i = 1; i < data.length; i++) {
      if (data[i][idxId] == id) {
        const currentRole = data[i][idxApprover];
        
        const items = dData.slice(1).filter(d => d[idxDId] == id);
        
        // 承認ルート判定のために明細情報を整形
        const checkItems = items.map(r => ({
           category: r[idxDCat],
           name: r[idxDItem],
           isAllowance: r[idxDAllow]
        }));
        
        // 判定には最も高額なもののカテゴリ、または代表として1つ目のカテゴリ等を使用
        const category = (items.length > 0 && idxDCat !== undefined) ? items[0][idxDCat] : '';
        const isAllowance = items.some(r => r[idxDAllow]);
        const amount = data[i][idxAmount];

        const route = getApprovalRoute(category, amount, checkItems, isAllowance);
        const idx = route.indexOf(currentRole);
        
        if (idx !== -1 && idx < route.length - 1) {
          rSheet.getRange(i + 1, idxApprover + 1).setValue(route[idx + 1]);
        } else {
          rSheet.getRange(i + 1, idxStatus + 1).setValue('承認済');
          rSheet.getRange(i + 1, idxApprover + 1).setValue('承認済');
        }
        SpreadsheetApp.flush();
        return { success: true };
      }
    }
    return { success: false, message: 'データが見つかりません' };

  } catch (e) {
    throw new Error('承認エラー: ' + e.message);
  } finally {
    lock.releaseLock();
  }
}

// --- 差戻し処理 (変更なし) ---
function rejectApplication(id, comment) {
  const lock = LockService.getScriptLock();
  try {
    lock.waitLock(30000);
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(SHEETS.RECEIPTS);
    const data = sheet.getDataRange().getValues();
    const colMap = createColumnMap(data[0]);
    
    const idxId = colMap['登録ID'];
    const idxStatus = colMap['ステータス'];
    const idxMemo = colMap['メモ'];

    for (let i = 1; i < data.length; i++) {
      if (data[i][idxId] == id) {
        if(idxStatus !== undefined) sheet.getRange(i + 1, idxStatus + 1).setValue('差戻し');
        if(idxMemo !== undefined) {
           const currentMemo = data[i][idxMemo];
           sheet.getRange(i + 1, idxMemo + 1).setValue(currentMemo + `\n[差戻し理由] ${comment}`);
        }
        SpreadsheetApp.flush();
        return { success: true };
      }
    }
  } catch(e) {
    throw new Error('エラー: ' + e.message);
  } finally {
    lock.releaseLock();
  }
}

// --- AI解析 (変更なし) ---
function analyzeReceiptImage(base64Image, mimeType) {
  if (!GEMINI_API_KEY) throw new Error('Gemini APIキーが設定されていません。');
  const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro:generateContent?key=${GEMINI_API_KEY}`;
  
  const prompt = `
    你是経理入力支援AIです。領収書画像を読み取り、以下のJSON形式で出力してください。
    
    【抽出ルール】
    1. use_date: 利用日(YYYY-MM-DD)。不明なら今日。
    2. store_name: 支払先・店名。
    3. total_amount: 税込合計金額(数値)。
    4. item_name: 最も代表的な但し書き・品目名(例: タクシー代、飲食代)。
    5. category: 品目から推測される勘定科目(旅費交通費/交際費/消耗品/会議費/研修費/その他)。不明なら空文字。
    6. client: 接待相手の社名や氏名(記載があれば)。なければ空文字。
    7. participants: 参加人数(記載があれば数値)。なければ空文字。
    8. has_invoice: Tから始まる13桁の登録番号があればtrue。
    9. summary_text: 【重要】領収書の読み取り内容（日付、店名、金額、登録番号、品目など）を要約したテキストを作成してください。

    出力例:
    {
      "use_date": "2024-04-01",
      "store_name": "セブンイレブン",
      "total_amount": 550,
      "item_name": "文房具代",
      "category": "消耗品",
      "client": "",
      "participants": "",
      "has_invoice": true,
      "summary_text": "[AI読取]\\n日付: 2024/04/01\\n店名: セブンイレブン..."
    }
    
    JSONのみを返してください。
  `;

  const payload = { contents: [{ parts: [{ text: prompt }, { inline_data: { mime_type: mimeType, data: base64Image } }] }] };
  const options = { method: 'post', contentType: 'application/json', payload: JSON.stringify(payload), muteHttpExceptions: true };

  try {
    const response = UrlFetchApp.fetch(url, options);
    const json = JSON.parse(response.getContentText());
    if (json.error) throw new Error(json.error.message);
    let text = json.candidates[0].content.parts[0].text;
    text = text.replace(/```json/g, '').replace(/```/g, '').trim();
    return JSON.parse(text);
  } catch (e) {
    console.error('AI Error:', e);
    throw new Error('AI解析失敗: ' + e.message);
  }
}

// --- 学習データ関連 (変更なし) ---
function updateLearningData(itemName, category) {
  if (!itemName || !category) return;
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(SHEETS.LEARNING);
  sheet.appendRow([itemName, category, 1]);
}

function predictCategoryByItem(itemName) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(SHEETS.LEARNING);
  const data = sheet.getDataRange().getValues();
  const counts = {};
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] === itemName) {
      const cat = data[i][1];
      counts[cat] = (counts[cat] || 0) + Number(data[i][2] || 1);
    }
  }
  let max = 0;
  let bestCategory = '';
  for (const [cat, count] of Object.entries(counts)) {
    if (count > max) { max = count; bestCategory = cat; }
  }
  return bestCategory; 
}

function suggestItemsByCategory(category) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(SHEETS.LEARNING);
  const data = sheet.getDataRange().getValues();
  const suggestions = {};
  for (let i = 1; i < data.length; i++) {
    if (data[i][1] === category) {
      const name = data[i][0];
      suggestions[name] = (suggestions[name] || 0) + Number(data[i][2] || 1);
    }
  }
  return Object.entries(suggestions)
    .sort((a, b) => b[1] - a[1])
    .map(s => s[0])
    .slice(0, 10);
}

function getMasters() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const accounts = ss.getSheetByName(SHEETS.ACCOUNTS).getDataRange().getValues().slice(1).map(r => r[0]);
  return { accounts: accounts };
}

function getApprovalRoute(category, amount, items, hasAllowance) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(SHEETS.RULES);
  const data = sheet.getDataRange().getValues();
  
  const colMap = createColumnMap(data[0]);
  const idxCat = colMap['対象科目'];
  const idxAmt = colMap['金額条件'];
  const idxKw = colMap['キーワード条件'];
  const idxAllow = colMap['日当条件'];
  const idxRoute = colMap['必須承認者ルート'];

  const rules = data.slice(1).sort((a, b) => a[1] - b[1]);

  for (const rule of rules) {
    let match = true;
    
    if (idxCat !== undefined && rule[idxCat] && rule[idxCat] !== '*' && rule[idxCat] !== category) match = false;
    if (idxAmt !== undefined && rule[idxAmt] && amount < rule[idxAmt]) match = false;
    if (idxKw !== undefined && rule[idxKw]) {
      const allText = items.map(i => i.name).join(' ');
      if (!allText.includes(rule[idxKw])) match = false;
    }
    if (idxAllow !== undefined) {
      const ruleAllowance = rule[idxAllow];
      if (String(ruleAllowance).toUpperCase() === 'TRUE' && !hasAllowance) match = false;
    }

    if (match) {
      if(idxRoute !== undefined) return rule[idxRoute].split(',').map(s => s.trim()).filter(s => s);
    }
  }
  return [];
}

function generateCSV(type) {
  const lock = LockService.getScriptLock();
  try {
    lock.waitLock(30000);

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const configSheet = ss.getSheetByName(SHEETS.CSV_CONFIG);
    const configData = configSheet.getDataRange().getValues();
    const configColMap = createColumnMap(configData[0]);
    const idxType = configColMap['出力種別'];
    const idxOrder = configColMap['列順'];
    const idxHeader = configColMap['ヘッダー名']; 
    const idxCharset = configColMap['文字コード']; 
    
    if (idxType === undefined || idxOrder === undefined) throw new Error('CSV設定シートの形式が不正です');

    const configs = configData.slice(1)
      .filter(r => r[idxType] === type)
      .sort((a, b) => a[idxOrder] - b[idxOrder]);

    if (!configs.length) throw new Error('CSV設定が見つかりません: ' + type);

    let charset = 'Shift_JIS';
    if (idxCharset !== undefined) {
        const settingCharset = String(configs[0][idxCharset]).trim();
        if (settingCharset.toUpperCase() === 'UTF-8') charset = 'UTF-8';
    }

    const rSheet = ss.getSheetByName(SHEETS.RECEIPTS);
    const rData = rSheet.getDataRange().getValues();
    const rColMap = createColumnMap(rData[0]);
    const rMap = new Map();
    const idxRId = rColMap['登録ID'];
    const idxStatus = rColMap['ステータス'];

    rData.slice(1).forEach(row => {
      const id = String(row[idxRId]).trim();
      if (String(row[idxStatus]).trim() === '承認済') {
        rMap.set(id, row);
      }
    });

    const dSheet = ss.getSheetByName(SHEETS.DETAILS);
    const dData = dSheet.getDataRange().getValues();
    const dColMap = createColumnMap(dData[0]);
    const idxDParent = dColMap['親登録ID'];
    
    let csvHeaderRow = configs.map(c => c[idxHeader] || c[2]);
    let csv = csvHeaderRow.join(',') + '\r\n';

    dData.slice(1).forEach(dRow => {
      const parentId = String(dRow[idxDParent]).trim();
      const rRow = rMap.get(parentId);
      if (!rRow) return;

      const line = configs.map(config => {
        const source = config[configColMap['参照元']];
        const colName = String(config[configColMap['カラム名']]).trim();
        const format = config[configColMap['フォーマット指定']];
        
        let value = '';
        if (source === '固定値') {
          value = colName;
        } else {
          let targetRow = (source === '領収書') ? rRow : dRow;
          let targetColMap = (source === '領収書') ? rColMap : dColMap;
          
          let idx = targetColMap ? targetColMap[colName] : undefined;
          if (idx !== undefined) value = targetRow[idx];
        }

        if (format === 'YYYYMMDD' && value instanceof Date) {
          value = Utilities.formatDate(value, Session.getScriptTimeZone(), 'yyyyMMdd');
        }
        return `"${String(value).replace(/"/g, '""')}"`;
      }).join(',');

      csv += line + '\r\n';
    });

    const blob = Utilities.newBlob('', 'text/csv', type + '.csv').setDataFromString(csv, charset);
    return {
      base64: Utilities.base64Encode(blob.getBytes()),
      filename: `${type}_${Utilities.formatDate(new Date(), Session.getScriptTimeZone(), 'yyyyMMdd_HHmm')}.csv`
    };
  } catch (e) {
    throw new Error('CSV出力エラー: ' + e.message);
  } finally {
    lock.releaseLock();
  }
}
